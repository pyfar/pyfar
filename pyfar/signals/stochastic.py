"""Module for generating stochastic signals as part of pyfar.signals."""
import numpy as np
import pyfar
from pyfar.dsp import fft


def noise(n_samples, spectrum="white", rms=1, sampling_rate=44100, seed=None):
    """
    Generate single or multi channel normally distributed white or pink noise.

    The pink noise is generated by applying a ``sqrt(1/f)`` filter to the
    spectrum.

    Parameters
    ----------
    n_samples : int
        The length of the signal in samples
    spectrum : str, optional
        ``white`` to generate noise with constant energy across frequency.
        ``pink`` to generate noise with constant energy across filters with
        constant relative bandwidth. The default is ``white``.
    rms : double, array like, optional
        The root mean square (RMS) value of the noise signal. A multi channel
        noise signal is generated if an array of RMS values is passed.
        The default is ``1``.
    sampling_rate : int, optional
        The sampling rate in Hz. The default is ``44100``.
    seed : int, None, optional
        The seed for the random generator. Pass a seed to obtain identical
        results for multiple calls. The default is ``None``, which will yield
        different results with every call.

    Returns
    -------
    signal : Signal
        The noise signal. The signal is in the time domain and has the ``rms``
        FFT normalization (see :py:func:`~pyfar.dsp.fft.normalization`). The
        type of the spectrum (``white``, ``pink``) and the RMS amplitude are
        written to `comment`.
    """

    # generate the noise
    rms = np.atleast_1d(rms)
    n_samples = int(n_samples)
    cshape = np.atleast_1d(rms).shape
    rng = np.random.default_rng(seed)
    noise = rng.standard_normal(np.prod(cshape + (n_samples, )))
    noise = noise.reshape(cshape + (n_samples, ))

    if spectrum == "pink":
        # apply 1/f filter in the frequency domain
        noise = fft.rfft(noise, n_samples, sampling_rate, 'none')
        noise /= np.sqrt(np.arange(1, noise.shape[-1]+1))
        noise = fft.irfft(noise, n_samples, sampling_rate, 'none')
    elif spectrum != "white":
        raise ValueError(
            f"spectrum is '{spectrum}' but must be 'white' or 'pink'")

    # level the noise
    rms_current = np.atleast_1d(np.sqrt(np.mean(noise**2, axis=-1)))
    for idx in np.ndindex(rms.shape):
        noise[idx] = noise[idx] / rms_current[idx] * rms[idx]

    # save to Signal
    nl = "\n"  # required as variable because f-strings cannot contain "\"
    comment = f"{spectrum} noise signal (rms = {str(rms).replace(nl, ',')})"

    signal = pyfar.Signal(
        noise, sampling_rate, fft_norm="rms", comment=comment)

    return signal


def pulsed_noise(n_pulse, n_pause, n_fade=90, repetitions=5, rms=1,
                 spectrum="pink", frozen=True, sampling_rate=44100, seed=None):
    """
    Generate single channel normally distributed pulsed white or pink noise.

    The pink noise is generated by applying a ``sqrt(1/f)`` filter to the
    spectrum.

    Parameters
    ----------
    n_pulse : int
        The length of the pulses in samples
    n_pause : int
        The length of the pauses between the pulses in samples.
    n_fade : int, optional
        The length of the squared sine/cosine fade-in and fade outs in samples.
        The default is ``90``, which equals approximately 2 ms at sampling
        rates of 44.1 and 48 kHz.
    repetitions : int, optional
        Specifies the number of noise pulses. The default is ``5``.
    rms : double, array like, optional
        The RMS amplitude of the white signal. The default is ``1``.
    spectrum: string, optional
        The noise spectrum, which can be ``pink`` or ``white``. The default is
        ``pink``.
    frozen : boolean, optional
        If ``True``, all noise pulses are identical. If ``False`` each noise
        pulse is a separate stochastic process. The default is ``True``.
    sampling_rate : int, optional
        The sampling rate in Hz. The default is ``44100``.
    seed : int, None, optional
        The seed for the random generator. Pass a seed to obtain identical
        results for multiple calls. The default is ``None``, which will yield
        different results with every call.

    Returns
    -------
    signal : Signal
        The noise signal. The Signal is in the time domain and has the ``rms``
        FFT normalization (see :py:func:`~pyfar.dsp.fft.normalization`).
        `comment` contains information about the selected parameters.
    """

    if n_pulse < 2 * n_fade:
        raise ValueError(
            "n_fade too large. It must be smaller than n_pulse/2.")

    # get the noise sample
    n_pulse = int(n_pulse)
    repetitions = int(repetitions)
    n_samples = n_pulse if frozen else n_pulse * repetitions

    p_noise = noise(n_samples, spectrum, rms, sampling_rate, seed).time
    p_noise = np.tile(p_noise, (repetitions, 1)) if frozen else \
        p_noise.reshape((repetitions, n_pulse))

    # fade the noise
    if n_fade > 0:
        n_fade = int(n_fade)
        fade = np.sin(np.linspace(0, np.pi/2, n_fade))**2
        p_noise[..., 0:n_fade] *= fade
        p_noise[..., -n_fade:] *= fade[::-1]

    # add the pause
    p_noise = np.concatenate((
        p_noise, np.zeros((repetitions, int(n_pause)))), -1)

    # reshape to single channel signal and discard final pause
    p_noise = p_noise.reshape((1, -1))[..., :-int(n_pause)]

    # save to Signal
    frozen_str = "frozen" if frozen else ""
    comment = (f"{frozen_str} {spectrum} pulsed noise signal (rms = {rms}, "
               f"{repetitions} repetitions, {n_pulse} samples pulse duration, "
               f"{n_pause} samples pauses, and {n_fade} samples fades.")

    signal = pyfar.Signal(
        p_noise, sampling_rate, fft_norm="rms", comment=comment)

    return signal


def reflection_density_room(
        room_volume, n_samples, sampling_rate=44100, speed_of_sound=None,
        max_reflection_density=10000):
    r"""
    Calculates the reflection density and starting time in a diffuse room.

    The reflection density and starting time based on the chapter
    5.3.4 of [#]_.
    The starting time :math:`t_0` can be calculated based on:

    .. math:: t_0 = \left(\frac{2 V \cdot \ln(2)}{4 \pi c^3}\right)^{1/3}

    where :math:`V` is the room volume in :math:`m^3` and :math:`c` is the
    speed of sound in the room. The reflection density :math:`\mu`
    is calculated based on the following equation:

    .. math:: \mu = \min{\left(\frac{4 \pi c^3 \cdot t^2}{V}, \mu_{max}\right)}

    with :math:`t` being the time vector in seconds based on ``sampling_rate``
    and ``n_samples`` and :math:`\mu_{max}` being the
    maximum reflection density.

    Notes
    -----
    This function can be used to generate the Dirac sequence for the
    room impulse response synthesis using
    :py:func:`pyfar.signals.dirac_sequence`.

    Parameters
    ----------
    room_volume : float
        Volume of the room :math:`V` in :math:`m^3`.
    n_samples : int
        The length of the signal in samples.
    sampling_rate : int, optional
        The sampling rate in Hz. The default is ``44100``.
    speed_of_sound : float, None, optional
        Speed of sound in the room.
        By default, the :py:attr:`~pyfar.constants.reference_speed_of_sound`
        is used.
    max_reflection_density : int, optional
        The maximum reflection density. The default is ``10 000`` as Schröder
        defined it in his thesis.

    Returns
    -------
    reflection_density : pyfar.TimeData
        reflection density :math:`\mu` in :math:`1/s^2` over time.
    t_0 : float
        The dirac sequence generation starts after :math:`t_0`.

    References
    ----------
    .. [#] D. Schröder, “Physically based real-time auralization of
           interactive virtual environments,” PhD Thesis, Logos-Verlag,
           Berlin, 2011. [Online].
           Available: https://publications.rwth-aachen.de/record/50580

    Examples
    --------
    Generate the reflection densities for a room with a different volumes.

    .. plot::

        >>> import pyfar as pf
        >>> n_samples = 8800
        >>> sampling_rate = 44100
        >>> for v in [100, 500, 1000, 5000]:
        >>>     reflection_density, t_0 = pf.signals.reflection_density_room(
        ...         v, n_samples, sampling_rate)
        >>>     ax = pf.plot.time(
        ...         reflection_density,
        ...         label=f"V={v} m$^3$ -> $t_0={t_0*1e3:.1f}$ ms")
        >>> ax.legend()
        >>> ax.set_title("Reflection density")

    """
    if speed_of_sound is None:
        speed_of_sound = pyfar.constants.reference_speed_of_sound

    # check input
    room_volume = float(room_volume)
    n_samples = int(n_samples)
    if max_reflection_density is not None:
        max_reflection_density = int(max_reflection_density)
        if max_reflection_density <= 0:
            raise ValueError("max_reflection_density must be positive.")

    speed_of_sound = float(speed_of_sound)
    if speed_of_sound <= 0:
        raise ValueError("speed_of_sound must be positive.")
    if room_volume <= 0:
        raise ValueError("room_volume must be positive.")
    if n_samples <= 0:
        raise ValueError("n_samples must be positive.")

    times = pyfar.Signal(np.zeros(n_samples), sampling_rate).times
    # calculate the reflection density
    mu = 4 * np.pi * speed_of_sound**3 * times**2 / room_volume
    if max_reflection_density is not None:
        mu[mu > max_reflection_density] = max_reflection_density
    mu = pyfar.TimeData(mu, times)

    # calculate the time of the first reflection
    t_0 = (2*room_volume*np.log(2)/(4*np.pi*speed_of_sound**3))**(1/3)

    # return the reflection density and the starting time
    return mu, t_0


def dirac_sequence(
        reflection_density, t_0, n_samples, sampling_rate=44100, seed=None):
    r"""Dirac sequence based on the reflection density over time.

    The Dirac sequence is generated based on the chapter 5.3.4 of [#]_.

    The time difference between each dirac in the sequence is Poisson
    distributed and can be calculated based on:

    .. math:: \Delta t_a = \frac{1}{\mu} \cdot \ln{\frac{1}{z}}

    with z being a random number in the following range :math:`z \in (0, 1]`
    and :math:`\mu` being the ``reflection_density`` in a room.
    Each dirac has an amplitude of 1 or -1, which is chosen
    randomly with equal probability.
    The dirac sequence generation starts after :math:`t_0`.

    Parameters
    ----------
    reflection_density : pyfar.TimeData
        reflection density :math:`\mu` in :math:`1/s^2` over time.
    t_0 : float
        The dirac sequence generation starts after :math:`t_0`.
        The unit is seconds.
    n_samples : int
        The length of the dirac sequence in samples.
    sampling_rate : int, optional
        The sampling rate of the dirac sequence in Hz.
        The default is 44100.
    seed : int, None, optional
        The seed for the random generator. Pass a seed to obtain identical
        results for multiple calls. The default is ``None``, which will yield
        different results with every call.
        See :py:func:`numpy.random.default_rng` for more information.

    Returns
    -------
    dirac_sequence : pyfar.Signal
        Signal of the generated dirac impulse sequence.

    References
    ----------
    .. [#] D. Schröder, “Physically based real-time auralization of
           interactive virtual environments,” PhD Thesis, Logos-Verlag,
           Berlin, 2011. [Online].
           Available: https://publications.rwth-aachen.de/record/50580
    """
    # check input
    if not isinstance(reflection_density, pyfar.TimeData):
        raise ValueError(
            "reflection_density must be a pyfar.TimeData object.")
    if t_0 < 0:
        raise ValueError("t_0 must be positive.")

    rng = np.random.default_rng(seed)
    dirac_sequence = pyfar.Signal(np.zeros(n_samples), sampling_rate)
    mu_times = reflection_density.times
    t_current = t_0
    i_current = np.argmin(np.abs(t_current-mu_times))
    t_max = reflection_density.times[-1]
    while True:
        # calculate next event time
        z = -rng.uniform(-1, 0) # uniform distribution in (0, 1]
        # Equation (5.43) interval size
        delta_ta = 1 / reflection_density.time[..., i_current] * np.log(1 / z)
        t_current += delta_ta

        if t_current > t_max:
            break

        i_current = np.argmin(np.abs(t_current-mu_times))

        dirac_sequence.time[..., i_current] = rng.choice([-1, 1], p=[0.5, 0.5])

    return dirac_sequence
